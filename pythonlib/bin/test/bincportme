#!/usr/bin/python
####!/usr/bin/python -w

# ================================================================
# John Kerl
# kerl.john.r@gmail.com
# 2005-01-25
# Ported to Python 2006-07-15

xxx port not complete!

#
# This program prints binomial coefficients, optionally reduced mod p.
# Examples:
#
# binc ch 7 4
# 35
# 
# binc -p 3 ch 7 4
# 2
# 
# binc row 7
# 1 7 21 35 35 21 7 1
# 
# binc -p 5 row 7
# 1 2 1 0 0 1 2 1
# 
# binc -p 7 row 7
# 1 0 0 0 0 0 0 1
# 
# binc tri 10 | colprint -r
# 1
# 1  1
# 1  2  1
# 1  3  3   1
# 1  4  6   4   1
# 1  5 10  10   5   1
# 1  6 15  20  15   6   1
# 1  7 21  35  35  21   7   1
# 1  8 28  56  70  56  28   8  1
# 1  9 36  84 126 126  84  36  9  1
# 1 10 45 120 210 252 210 120 45 10 1
#
# binc -p 2 tri 10
# 1
# 1 1
# 1 0 1
# 1 1 1 1
# 1 0 0 0 1
# 1 1 0 0 1 1
# 1 0 1 0 1 0 1
# 1 1 1 1 1 1 1 1
# 1 0 0 0 0 0 0 0 1
# 1 1 0 0 0 0 0 0 1 1
# 1 0 1 0 0 0 0 0 1 0 1
#
# binc -p 7 tri 10
# 1
# 1 1
# 1 2 1
# 1 3 3 1
# 1 4 6 4 1
# 1 5 3 3 5 1
# 1 6 1 6 1 6 1
# 1 0 0 0 0 0 0 1
# 1 1 0 0 0 0 0 1 1
# 1 2 1 0 0 0 0 1 2 1
# 1 3 3 1 0 0 0 1 3 3 1
#
# binc -p 2 -dot tri 30
# o
# oo
# o o
# oooo
# o   o
# oo  oo
# o o o o
# oooooooo
# o       o
# oo      oo
# o o     o o
# oooo    oooo
# o   o   o   o
# oo  oo  oo  oo
# o o o o o o o o
# oooooooooooooooo
# o               o
# oo              oo
# o o             o o
# oooo            oooo
# o   o           o   o
# oo  oo          oo  oo
# o o o o         o o o o
# oooooooo        oooooooo
# o       o       o       o
# oo      oo      oo      oo
# o o     o o     o o     o o
# oooo    oooo    oooo    oooo
# o   o   o   o   o   o   o   o
# oo  oo  oo  oo  oo  oo  oo  oo
# o o o o o o o o o o o o o o o o
# ================================================================

import sys

# ----------------------------------------------------------------
def usage:
	print "Usage: 0 [options] ch  {n} {k}" .
	print "Or   : 0 [options] row {n}" .
	print "Or   : 0 [options] tri {nmax}" .
	print "Computes binomial coefficients, optionally reduced mod p." .
	print "  ch:  compute a single binomial coefficient." .
	print "  row: compute a row of Pascal's triangle: n choose k for k = 0 to kmax." .
	print "  tri: compute nmax rows of Pascal's triangle." .
	print "Options:" .
	print "  --help:    Print this message." .
	print "  -p {p}:    Prime to reduce by." .
	print "  -lucas:    Reduce mod p using Lucas Theorem (default).  p must be prime." .
	print "  -kerl:     Reduce mod p using Kerl's slow method.  p must be prime." .
	print "  -modafter: Reduce mod p after computing n choose k (prone to overflow)" .
	print "  -dot:      Print just a dot for non-zero values, space for zeroes."
	sys.exit(1)

# ----------------------------------------------------------------
how  = "lucas"
dots = 0
p    = 0

while (@ARGV && (ARGV[0] =~ m/^-/)):
	opt = shift @ARGV
	if (opt eq "--help"):
		usage()
	elif (opt eq "-p"):
		usage() unless @ARGV
		p = shift @ARGV
	elif (opt eq "-lucas"):
		how = "lucas"
	elif (opt eq "-kerl"):
		how = "kerl"
	elif (opt eq "-modafter"):
		how = "modafter"
	elif (opt eq "-dot"):
		dots = 1
	else:
		usage()

usage() unless @ARGV
what = shift @ARGV
if (what eq "ch"):
	usage() unless (@ARGV == 2)
	n = shift @ARGV
	k = shift @ARGV
	do_one(n, k, p)
	print

elif (what eq "row"):
	usage() unless (@ARGV == 1)
	n    = shift @ARGV
	for (k = 0; k <= n; k++):
		if ((k > 0) && !dots):
			print " "
		do_one(n, k, p)
	print

elif (what eq "tri"):
	usage() unless (@ARGV == 1)
	nmax = shift @ARGV
	for (n = 0; n <= nmax; n++):
		for (k = 0; k <= n; k++):
			if ((k > 0) && !dots):
				print " "
			do_one(n, k, p)
		print

else:
	usage()

# ----------------------------------------------------------------
def do_one(n, k, p):
	if ((p == 0) || (how eq "z")):
		b = binc(n, k)
	elif (how eq "lucas"):
		b = bincp_lucas(n, k, p)
	elif (how eq "kerl"):
		b = bincp_kerl(n, k, p)
	elif (how eq "modafter"):
		b = binc(n, k) % p
	else:
		usage()

	if (dots):
		if (b == 0):
			print " "
		else:
			#print "."
			print "o"
	else:
		print b

# ----------------------------------------------------------------
def binc(n, k):
	if (k > n):
		return 0
	if (k < 0):
		return 0
	if (k > int(n/2)):
		k = n - k

	rv = 1
	for j in range(0, k):
		rv *= n - j
		rv /= j + 1
	return rv

# ----------------------------------------------------------------
# See http://mathworld.wolfram.com/LucasCorrespondenceTheorem.html.
# Write n and k in base-p notation, with digits n_i and k_i.  Then (n choose k)
# is equivalent mod p to the product of the (n_i choose k_i)'s.

def bincp_lucas(n, k, p):
	if (k > int(n/2)):
		k = n - k
	rv = 1

	while (n || k):
		n_i = n % p; n = int(n / p)
		k_i = k % p; k = int(k / p)
		b = binc(n_i, k_i)
		rv *= b
		rv %= p

	return rv

# ----------------------------------------------------------------
def bincp_kerl(n, k, p):
	if (k > n):
		return 0
	if (k < 0):
		return 0
	if (k > int(n/2)):
		k = n - k

	numer = 1
	denom = 1
	pcount = 0

	rv = 1
	for j in range(0, k):
		curnumer = n - j
		while ((curnumer % p) == 0):
			pcount += 1
			curnumer /= p
		numer *= curnumer
		numer %= p

		curdenom = j+1
		while ((curdenom % p) == 0):
			pcount -= 1
			curdenom /= p
		denom *= curdenom
		denom %= p
	if (pcount > 0):
		rv = 0
	elif (pcount == 0):
		rv = numer * modrecip(denom, p)
		rv %= p
	else:
		print "0: coding error; pcount=pcount."
		sys.exit(1)
	return rv

# ----------------------------------------------------------------
# xxx should use modpower(a, p-2) w/ repeated squaring.
def modrecip(a, p):
	a %= p
	if ((a % p) == 0):
		print "modrecip: division by zero."
		sys.exit(1)
	rv = 1
	e = p-2
	while (e--):
		rv *= a
		rv %= p
	return rv
